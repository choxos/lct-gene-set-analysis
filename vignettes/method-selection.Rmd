---
title: "Method Selection and Comparison"
author: "Sara Khademioureh"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Method Selection and Comparison}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview

lctGSA provides four covariance estimation methods for the Linear Combination Test. This vignette helps you choose the right method for your data.

## Method Comparison Table

| Method | Speed | Best For | Key Advantage | When to Avoid |
|--------|-------|----------|---------------|---------------|
| **Shrinkage** | Fast (0.5-1s) | Balanced designs | Optimal power, default choice | Highly unbalanced groups |
| **Ridge** | Fast (0.5-1s) | Unbalanced designs | Better Type I error control | Dense networks only |
| **Graphical Lasso** | Slow (4-8s) | Network analysis | Identifies sparse structures | Large gene sets |
| **Adaptive Lasso** | Moderate (1-2s) | Feature selection | Oracle properties | Very small samples |

## Detailed Recommendations

### Shrinkage (Default)

**Use when:**
- Groups are balanced or nearly balanced
- You want the fastest analysis
- General-purpose gene set testing

**Parameters:**
- `method = "shrinkage"`
- `s0 = 0` (default)

**Example:**
```{r shrinkage, eval = FALSE}
library(lctGSA)

results <- perform_LCT(gene_sets, expression_data, phenotype,
                        method = "shrinkage", nbPermutations = 1000)
```

### Ridge

**Use when:**
- Groups are highly unbalanced (e.g., 25 controls vs 5 cases)
- You need robust Type I error control
- Sample sizes differ substantially between groups

**Parameters:**
- `method = "ridge"`
- `lambda = 1` (default, increase for stronger regularization)

**Tuning lambda:**
- Higher lambda = more regularization (more stable, less power)
- Try 0.1, 1, 5, 10 if unsure

**Example:**
```{r ridge, eval = FALSE}
# Standard usage
results_ridge <- perform_LCT(gene_sets, expression_data, phenotype,
                               method = "ridge", nbPermutations = 1000)

# Strong regularization for very unbalanced designs
results_ridge_strong <- perform_LCT(gene_sets, expression_data, phenotype,
                                     method = "ridge", nbPermutations = 1000)

# Note: lambda tuning requires using LCT.ridge() directly
p_value <- LCT.ridge(gene_expression_subset, phenotype,
                      nbPermutations = 1000, lambda = 5)
```

### Graphical Lasso

**Use when:**
- You want to identify gene network structures
- Analyzing biological pathways with known sparse interactions
- Conditional independence is important

**Parameters:**
- `method = "glasso"`
- `rho = 0.4` (default sparsity parameter)

**Tuning rho:**
- Higher rho = sparser network (more edges set to 0)
- Try 0.1 (dense), 0.4 (moderate), 0.8 (sparse)

**Trade-offs:**
- Much slower than other methods
- Better for interpretable network structures
- May lose power if network is actually dense

**Example:**
```{r glasso, eval = FALSE}
# Standard usage
results_glasso <- perform_LCT(gene_sets, expression_data, phenotype,
                                method = "glasso", nbPermutations = 1000)

# Sparse network assumption
p_value_sparse <- LCT.glasso(gene_expression_subset, phenotype,
                               nbPermutations = 1000, rho = 0.8)
```

### Adaptive Lasso

**Use when:**
- You want automatic feature selection
- Oracle properties are desired (consistent selection + efficient estimation)
- Moderate to large sample sizes available

**Parameters:**
- `method = "adaptive_lasso"`
- `lambda = 0.5`, `n = 0.8` (default)

**Tuning:**
- `lambda`: Overall regularization strength
- `n`: Adaptive weight exponent (higher = more aggressive)

**Trade-offs:**
- Requires stable initial estimates (avoid with n < 30)
- Two parameters to tune
- Good theoretical properties

**Example:**
```{r adaptive, eval = FALSE}
results_adaptive <- perform_LCT(gene_sets, expression_data, phenotype,
                                  method = "adaptive_lasso",
                                  nbPermutations = 1000)
```

## Decision Tree

```
Is your design unbalanced (group sizes differ by >3:1)?
├─ Yes → Use RIDGE
└─ No → Continue

Do you need network structure information?
├─ Yes → Use GLASSO (if time permits)
└─ No → Continue

Do you have >50 samples and want feature selection?
├─ Yes → Use ADAPTIVE LASSO
└─ No → Use SHRINKAGE (default)
```

## Computational Performance

Based on 1000 permutations per gene set:

```{r performance, echo = FALSE, eval = FALSE}
performance <- data.frame(
  Method = c("Shrinkage", "Ridge", "Adaptive Lasso", "Graphical Lasso"),
  Time_per_GS = c("0.5-1 sec", "0.5-1 sec", "1-2 sec", "4-8 sec"),
  Recommended_Max_GS = c("Unlimited", "Unlimited", "1000", "100")
)
knitr::kable(performance)
```

**Performance tips:**
- Start with fewer permutations (100) for initial exploration
- Use 1000+ permutations for final analysis
- Consider parallel processing for large studies (future feature)

## Practical Example: Method Comparison

```{r example, eval = FALSE}
library(lctGSA)
set.seed(123)

# Simulate data
n_genes <- 200
n_samples <- 40
expression <- matrix(rnorm(n_genes * n_samples), nrow = n_genes)
rownames(expression) <- paste0("Gene", 1:n_genes)

# Add differential expression
phenotype <- c(rep(0, 20), rep(1, 20))
expression[1:30, phenotype == 1] <- expression[1:30, phenotype == 1] + 1.5

# Define gene set
gene_set <- list(TestPathway = paste0("Gene", 1:50))

# Compare all methods
methods <- c("shrinkage", "ridge", "glasso", "adaptive_lasso")
results <- lapply(methods, function(m) {
  perform_LCT(gene_set, as.data.frame(expression), phenotype,
               method = m, nbPermutations = 1000)
})
names(results) <- methods

# Display results
comparison <- do.call(rbind, results)
print(comparison)
```

## Statistical Considerations

### Type I Error Control

All methods maintain nominal Type I error rate (≈ 0.05) under the null hypothesis, but:
- **Ridge**: Best for unbalanced designs
- **Shrinkage**: Best for balanced designs
- **GLASSO/Adaptive Lasso**: May be slightly conservative

### Statistical Power

Relative power depends on data structure:
- **Dense correlations**: Shrinkage ≥ Ridge > Adaptive Lasso > GLASSO
- **Sparse networks**: GLASSO > Adaptive Lasso > Shrinkage ≈ Ridge
- **Unbalanced design**: Ridge > Shrinkage > others

## References

- Shrinkage: Schäfer & Strimmer (2005). doi:10.2202/1544-6115.1175
- Ridge: Van Wieringen & Peeters (2016). doi:10.1016/j.csda.2016.05.012
- GLASSO: Friedman et al. (2008). doi:10.1093/biostatistics/kxm045
- Adaptive Lasso: Rothman et al. (2009). doi:10.1198/jasa.2009.0101
